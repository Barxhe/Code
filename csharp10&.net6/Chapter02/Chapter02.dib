#!csharp

/* Traditionally, every .cs file that needs to import namespaces would have to start with using
statements to import those namespaces. Namespaces like System and System.Linq are needed
in almost all .cs files, so the first few lines of every .cs file often had at least a few using
statements, as shown in the following code*/

using System; // import the system namespace 
using System.Linq;
using System.Collections.Generic;

#!csharp

 /* 
 1.The global using statement means you only need to import a namespace in one .cs file
and it will be available throughout all
 2.Recommend creating a separate file for those statements named something
like GlobalUsings.cs or GlobalNamespaces.cs, as shown in the following code*/

global using System;
global using System.Linq;
global using System.Collections.Generic;

#!csharp

/*1. In Solution Explorer, select the Vocabulary project, toggle on the Show All Files
button, and note the compiler-generated bin and obj folders are visible.
2. Expand the obj folder, expand the Debug folder, expand the net6.0 folder, and open the
file named Vocabulary.GlobalUsings.g.cs.
3. Note this file is automatically created by the compiler for projects that target .NET 6.0,
and that it imports some commonly used namespaces including System.Threading, as
shown in the following code:
// <autogenerated />
*/
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

#!html

/*4. Close the Vocabulary.GlobalUsings.g.cs file.
5. In Solution Explorer, select the project, and then add additional entries to the project
file to control which namespaces are implicitly imported, as shown highlighted in the
following markup:
*/
<Project Sdk="Microsoft.NET.Sdk">
 <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
 </PropertyGroup>
 <ItemGroup>
    <Using Remove="System.Threading" />
    <Using Include="System.Numerics" />
 </ItemGroup>
</Project>

/*6. Save the changes to the project file.
*/

#!csharp

/*
7. Expand the obj folder, expand the Debug folder, expand the net6.0 folder, and open the
file named Vocabulary.GlobalUsings.g.cs.
8. Note this file now imports System.Numerics instead of System.Threading, as shown
highlighted in the following code:
*/
// <autogenerated />
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading.Tasks;
global using global::System.Numerics;


/*You can disable the implicitly imported namespaces feature for all SDKs by removing an entry
in the project file, as shown in the following markup:
*/
<ImplicitUsings>enable</ImplicitUsings>

#!csharp

using System; // a semicolon indicates the end of a statement
using System.Reflection; //


namespace Basics
{ // an open brace indicates the start of a block
    class Program
    {
        static void Main(string[] args)
        {
            //Console.WriteLine("Hello World!"); // a statement
            Assembly? assembly = Assembly.GetEntryAssembly();
            if (assembly == null) return;

            //loop through the assemblies that is app references
            forearch(AssemblyName name in assembly.GetReferencedAssemblies())
            {
                // load the assambly so we can read its details
                Assembly a = Assembly.Load(name);

                int methodCount = 0;
                foreach(TypeInfo t in a.DefinedTypes)
                {
                    methodCount += t.GetMethods().Count();
                }

                Console.WriteLine(
                    "{0:N0} types with (1:N0) methods in {2} assembly.",
                    arg0: a.DefinedTypes.Count(),
                    arg1: methodCount,arg2: name.Name
                );
            }
        }
    }

/*Why does the System.Runtime assembly contain zero types? 
This assembly is special because it contains only type-forwarders rather
than actual types. A type-forwarder represents a type that has been
implemented outside of .NET or for some other advanced reason*/

#!csharp

/*Understanding verbatim strings
When storing text in a string variable, you can include escape sequences, which represent
special characters like tabs and new lines using a backslash, as shown in the following code:
*/
string fullNameWithTabSeparator = "Bob\tSmith";
/*But what if you are storing the path to a file on Windows, and one of the folder names starts
with a T, as shown in the following code?
string filePath = "C:\televisions\sony\bravia.txt";
The compiler will convert the \t into a tab character and you will get errors!
You must prefix with the @ symbol to use a verbatim literal string, as shown in the following
code:
*/
string filePath = @"C:\televisions\sony\bravia.txt";

/*To summarize:
• Literal string: Characters enclosed in double-quote characters. They can use escape
characters like \t for tab. To represent a backslash, use two: \\.
• Verbatim string: A literal string prefixed with @ to disable escape characters so that a
backslash is a backslash. It also allows the string value to span multiple lines because
the white space characters are treated as themselves instead of instructions to the
compiler.
• Interpolated string: A literal string prefixed with $ to enable embedded formatted
variables. You will learn more about this later in this chapter.
